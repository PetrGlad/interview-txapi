/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package petrlgad.txapi

import com.google.gson.Gson
import com.zaxxer.hikari.HikariDataSource
import org.slf4j.LoggerFactory
import spark.Request
import spark.Response
import spark.Spark.*
import java.math.BigDecimal
import javax.sql.DataSource

typealias AccountId = String
typealias CurrencyId = String

data class Account(val id: AccountId,
                   val value: BigDecimal,
                   val currency: CurrencyId)

data class Transfer(val from_account_id: AccountId,
                    val to_account_id: AccountId,
                    val amount: BigDecimal,
                    val currency: CurrencyId)

val LOGGER = LoggerFactory.getLogger("petrglad.txapi.app")

fun setupDb(jdbcUrl: String): DataSource {
    val ds = HikariDataSource()
    ds.jdbcUrl = jdbcUrl
    ds.isAutoCommit = false
    ds.connection.use { conn ->
        conn.createStatement().use {
            it.execute("create table account (" +
                    "id varchar(256) primary key, " +
                    "value decimal(12, 4)," +
                    "currency char(3) )")
        }
        conn.commit()
    }
    return ds
}

fun main(args: Array<String>) {
    val dataSource = setupDb("jdbc:h2:mem:txapi")
    val jsonContentType = "application/json; charset=utf-8"
    val gson = Gson()
    port(8080)
    get("/accounts/list") { req: Request, resp: Response ->
        dataSource.connection.use { conn ->
            val result = ArrayList<Account>()
            val stmt = conn.prepareStatement("select id, value, currency from account")
            val rs = stmt.executeQuery()
            while (rs.next()) {
                result.add(Account(
                        rs.getString(1),
                        rs.getBigDecimal(2),
                        rs.getString(3)))
            }
            resp.type(jsonContentType)
            gson.toJson(result)
        }
    }
    put("/accounts/by-id/:id") { req: Request, resp: Response ->
        dataSource.connection.use { conn ->
            require(req.contentType().startsWith("application/json")) {
                "JSON body is required, got content type ${req.contentType()}"
            }
            val acc = gson.fromJson(req.body(), Account::class.java)
            val stmt = conn.prepareStatement("insert into account (id, value, currency) values (?, ?, ?) ")
            stmt.setString(1, acc.id)
            stmt.setBigDecimal(2, acc.value)
            stmt.setString(3, acc.currency)
            stmt.executeUpdate()
            conn.commit()
            resp.type(jsonContentType)
            gson.toJson("OK")
        }
    }
    put("/transfers/by-owner/:owner/by-id/:id") { req: Request, resp: Response ->
        dataSource.connection.use { conn ->
            require(req.contentType().startsWith("application/json")) {
                "JSON body is required, got content type ${req.contentType()}"
            }
            val tx = gson.fromJson(req.body(), Transfer::class.java)
            fun updateBalance(accId: String, d: BigDecimal): Int {
                val stmt = conn.prepareStatement("update account set value = value + ? where id = ? and currency = ?")
                stmt.setBigDecimal(1, d)
                stmt.setString(2, accId)
                stmt.setString(3, tx.currency)
                return stmt.executeUpdate()
            }
            LOGGER.info("Got tx $tx")
            require(updateBalance(tx.from_account_id, -tx.amount) == 1) {
                "Source account #${tx.from_account_id} is not found."
            }
            require(updateBalance(tx.to_account_id, tx.amount) == 1) {
                "Destination account #${tx.to_account_id} is not found."
            }
            conn.commit()
            resp.type(jsonContentType)
            gson.toJson("OK")
            TODO("Ensure transfers are within limits")
        }
    }
}
